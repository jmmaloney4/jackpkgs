{
  lib,
  pkgs,
  testHelpers,
}: let
  inherit (testHelpers.justHelpers) mkRecipe mkRecipeWithParams optionalLines;
  just = pkgs.just;

  # Helper to create a test that validates a justfile with the just parser
  mkJustParseTest = name: justfileContent:
    pkgs.runCommand "test-just-parse-${name}" {
      nativeBuildInputs = [just];
    } ''
      # Write the justfile
      cat > justfile << 'EOF'
      ${justfileContent}
      EOF

      # Validate it parses correctly
      echo "Testing justfile parsing for: ${name}"
      cat justfile
      echo "---"

      # Use --dump to validate syntax (exits non-zero on parse errors)
      ${just}/bin/just --dump > /dev/null

      # Use --list to ensure recipes are recognized
      ${just}/bin/just --list

      echo "âœ… Justfile parsed successfully"
      touch $out
    '';
in {
  # Test a simple single-command recipe
  testSingleRecipe = mkJustParseTest "single-recipe" (mkRecipe "build" "Build the project" [
    "echo 'Building...'"
  ]);

  # Test multiple recipes
  testMultipleRecipes = mkJustParseTest "multiple-recipes" (
    lib.concatStringsSep "\n" [
      (mkRecipe "build" "Build the project" [
        "echo 'Building...'"
        "make build"
      ])
      (mkRecipe "test" "Run tests" [
        "echo 'Testing...'"
        "make test"
      ])
      (mkRecipe "deploy" "Deploy to production" [
        "@echo 'Deploying...'"
        "make deploy"
      ])
    ]
  );

  # Test recipe with just variables (parameters)
  testRecipeWithVariables = mkJustParseTest "recipe-with-variables" (
    mkRecipeWithParams "run" [''args=""''] "Run with args" [
      "./script {{args}}"
      "echo 'Done: {{args}}'"
    ]
  );

  # Test recipe with dependencies
  testRecipeWithDependencies = mkJustParseTest "recipe-with-dependencies" ''
    # Build the project
    build:
        echo 'Building...'
        make build

    # Deploy (depends on build)
    deploy: build
        echo 'Deploying...'
        make deploy
  '';

  # Test conditional lines in a real justfile
  testConditionalRecipe = mkJustParseTest "conditional-recipe" (
    lib.concatStringsSep "\n" (
      ["# Authenticate with GCP"]
      ++ optionalLines true [
        "auth:"
        "    gcloud auth login"
      ]
      ++ [""]
      ++ optionalLines false [
        "# This recipe should not appear"
        "never:"
        "    echo 'This should not be here'"
      ]
    )
  );

  # Test complex real-world justfile similar to our actual usage
  testComplexJustfile = mkJustParseTest "complex-justfile" (
    lib.concatStringsSep "\n" [
      (mkRecipe "default" "List available recipes" [
        "@just --list"
      ])
      ""
      (mkRecipe "fmt" "Format code" [
        "treefmt"
      ])
      ""
      (mkRecipe "check" "Run checks" [
        "nix flake check"
      ])
      ""
      (mkRecipe "build" "Build the project" [
        "nix build"
      ])
      ""
      (mkRecipe "test" "Run tests" [
        "nix build .#checks.aarch64-darwin.mkRecipe-test"
        "nix build .#checks.aarch64-darwin.optionalLines-test"
      ])
    ]
  );

  # Test recipe with multiline shell commands (backslash continuation)
  testMultilineCommand = mkJustParseTest "multiline-command" (mkRecipe "multiline" "Multiline command" [
    ''echo "line 1" \''
    ''&& echo "line 2" \''
    ''&& echo "line 3"''
  ]);

  # Test recipe with special characters that need quoting
  testSpecialChars = mkJustParseTest "special-chars" (mkRecipe "special" "Special characters" [
    ''echo "Hello, World!"''
    ''echo 'Single quotes work too' ''
    ''echo "Quotes: \" and '"''
  ]);

  # Test empty recipe (edge case)
  testEmptyRecipe = mkJustParseTest "empty-recipe" (mkRecipe "empty" "Empty recipe" []);

  # Test recipe with shebang (inline script)
  testShebangRecipe = mkJustParseTest "shebang-recipe" ''
    # Script recipe
    script:
        #!/usr/bin/env bash
        set -euo pipefail
        echo "Running inline script"
        echo "With multiple lines"
  '';

  # Test full justfile as it might be generated by the just-flake module
  testRealWorldGeneration = let
    hasGcp = true;
    hasPython = true;
    quotaProject = "my-project-123";
  in
    mkJustParseTest "real-world-generation" (
      lib.concatStringsSep "\n" (
        # direnv feature
        [
          (mkRecipe "allow" "Allow direnv" [
            "direnv allow"
          ])
          ""
        ]
        # infra feature (conditional)
        ++ optionalLines hasGcp [
          (mkRecipe "auth" "Authenticate with GCP" [
            "gcloud auth login --update-adc"
            "gcloud auth application-default set-quota-project ${quotaProject}"
          ])
          ""
        ]
        # python feature (conditional)
        ++ optionalLines hasPython [
          (mkRecipe "venv" "Enter Python virtual environment" [
            "@echo 'Activating venv...'"
            "nix develop .#python"
          ])
          ""
        ]
        # Always present recipes
        ++ [
          (mkRecipe "fmt" "Format code" [
            "treefmt"
          ])
          ""
          (mkRecipe "check" "Run all checks" [
            "nix flake check"
          ])
        ]
      )
    );

  # Test mkRecipeWithParams with single parameter
  testRecipeWithSingleParam = mkJustParseTest "recipe-with-single-param" (
    mkRecipeWithParams "deploy" [''env="dev"''] "Deploy to environment" [
      "echo 'Deploying to {{env}}'"
      "kubectl apply -f {{env}}.yaml"
    ]
  );

  # Test mkRecipeWithParams with multiple parameters
  testRecipeWithMultipleParams = mkJustParseTest "recipe-with-multiple-params" (
    mkRecipeWithParams "process" [''input=""'' ''output=""'' ''mode="fast"''] "Process file" [
      "#!/usr/bin/env bash"
      "set -euo pipefail"
      ''echo "Processing {{input}} -> {{output}} (mode: {{mode}})"''
      ''./processor --input "{{input}}" --output "{{output}}" --mode "{{mode}}"''
    ]
  );

  # Test mkRecipeWithParams with no parameters (backward compat)
  testRecipeWithNoParams = mkJustParseTest "recipe-with-no-params" (
    mkRecipeWithParams "simple" [] "Simple recipe" [
      "echo 'No parameters needed'"
    ]
  );
}
