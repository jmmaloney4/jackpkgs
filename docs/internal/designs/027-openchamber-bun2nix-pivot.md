<<<<<<< openchamber
# ADR-027: OpenChamber Packaging — Pivot to bun2nix

## Status

Accepted — Implemented

**Supersedes:** ADR-026

## Context

ADR-026 proposed using a fixed-output derivation (FOD) with `bun install` and `cp -rL` to dereference Bun's symlink-based `node_modules` layout. After implementation, this approach failed on multiple fronts:

1. **`cp -rL` destroys Bun's module resolution.** Bun creates a symlink-heavy `node_modules` where packages point into `.bun/install/cache/`. Dereferencing these symlinks creates a flattened structure where internal `require()` calls between packages break (e.g., `body-parser` present under `.bun/node_modules` but not exposed at top-level).
2. **Build-time failures.** `vite build` failed with `Cannot find module 'rollup/parseAst'` — the flattened `node_modules` broke Vite's dependency tree traversal.
3. **17+ minute `fixupPhase`.** Dereferenced `node_modules` contains thousands of individual files. Nix's `fixupPhase` walks every file for shebang patching, reference scanning, and stripping.
4. **Hash bootstrapping friction.** FOD uses `lib.fakeSha256` requiring manual hash prefetch; every upstream dependency change invalidates the entire cache.

Research found **`nix-community/bun2nix`** as the idiomatic solution: per-package FODs using integrity hashes from `bun.lock`, preserving Bun's symlink structure, with full Nix sandbox support.

## Decision

Use **bun2nix** (`fetchBunDeps` + `mkDerivation`) to package OpenChamber.

## Implementation

### Architecture

```
flake.nix
├── inputs.bun2nix = github:nix-community/bun2nix
└── packages.openchamber = callPackage ./pkgs/openchamber {
      opencode = inputs.llm-agents.packages.${system}.opencode;
      bun2nix-cli = inputs.bun2nix.packages.${system}.bun2nix;
    };

pkgs/openchamber/
├── default.nix    — derivation using bun2nix-cli.mkDerivation
└── bun.nix        — generated by `bun2nix`, modified for workspace packages
```

### How bun2nix works

bun2nix exposes its API through **passthru attributes** on `inputs.bun2nix.packages.${system}.bun2nix`:

- **`fetchBunDeps { bunNix }`** — produces a store path with `share/bun-cache/` (symlinks) and `share/bun-packages/` (actual package contents, one directory per `<pkg>@<ver>`)
- **`mkDerivation`** — wraps `stdenv.mkDerivation` with a setup hook that runs three phases before `buildPhase`:
  1. `bunSetInstallCacheDirPhase` — copies `bunDeps/share/bun-cache/` to `$TMPDIR`, sets `$BUN_INSTALL_CACHE_DIR`
  2. `bunNodeModulesInstallPhase` — runs `bun install --linker=isolated --ignore-scripts`
  3. `bunLifecycleScriptsPhase` — runs `bun install` again with scripts enabled (e.g., `patch-package`)
- **`hook`** — the Nix setup hook used internally by `mkDerivation`

### The manifest-and-link strategy

The core challenge: after `bun install --linker=isolated`, `node_modules/` contains symlinks that point through `.bun/` into the ephemeral `$BUN_INSTALL_CACHE_DIR`. Copying these to `$out` creates dangling symlinks.

We solve this with a two-step approach:

**Step 1 — Build-time manifest.** During `buildPhase` (while `node_modules` is live), we scan every symlink in `node_modules/` and extract the `<pkg>@<ver>` identifier from the `.bun/` target path:

```
node_modules/express → .bun/express@5.2.1/node_modules/express
                             ^^^^^^^^^^^^^ captured as pkg@ver
```

For scoped packages:
```
node_modules/@codemirror/autocomplete → ../.bun/@codemirror/autocomplete@6.20.0/node_modules/...
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ captured
```

This manifest (a text file of `name|pkg@ver` pairs) is saved to `$TMPDIR`.

**Step 2 — Install-time linking.** During `installPhase`, we read the manifest and create symlinks from `$out/.../node_modules/<name>` directly to `$bunDeps/share/bun-packages/<pkg@ver>` — the permanent nix store path. No copying, no chasing ephemeral symlink chains.

A critical detail: Bun adds a `+wyhash` suffix for peer-dependency variants (e.g., `react-dom@19.2.4+b1ab299f0a400331`). These must be stripped (`${pkgver%%+*}`) before the bunDeps lookup, since `fetchBunDeps` stores packages without the variant suffix.

### What gets installed

The server runtime needs surprisingly little:

- `packages/web/dist/` — Vite-built SPA (static assets)
- `packages/web/server/` — pre-compiled Express server JS
- `packages/web/bin/cli.js` — CLI entrypoint (spawns bun to run server)
- `packages/web/public/` — static assets
- `packages/web/package.json` — read by cli.js for version info
- Two `node_modules/` trees (root + `packages/web/`) with ~80 symlinked packages

The wrapper runs `bun cli.js serve` with `opencode`, `bun`, and `nodejs` on PATH.

### Workspace handling in bun.nix

OpenChamber is a monorepo with workspace packages (`@openchamber/desktop`, `@openchamber/ui`, `@openchamber/web`, `openchamber`). The `bun2nix`-generated `bun.nix` uses `copyPathToStore` for local workspace paths, which doesn't work when the source is a `fetchFromGitHub` derivation. We embed `workspaceSrc` directly in `bun.nix`:

```nix
workspaceSrc = fetchFromGitHub {
  owner = "btriapitsyn";
  repo = "openchamber";
  ...
};
# Then:
"@openchamber/web" = "${workspaceSrc}/packages/web";
```

## Problems Encountered During Implementation

### Problem 1: macOS `readlink -f` doesn't exist

Early attempts used `readlink -f` to resolve symlink chains. macOS's `readlink` doesn't support `-f`. Nix builds use the system `readlink` unless GNU coreutils is explicitly added. Manifested as 0 packages being resolved (silent failure).

**Fix:** Parse the symlink target directly with regex instead of chasing the chain.

### Problem 2: `.bun/` entries are real directories, not symlinks

We initially assumed the `.bun/` cache structure contained symlinks to the nix store (`bunDeps/share/bun-packages/`). In reality, on macOS with `--backend=symlink`, the chain is:

```
node_modules/express → .bun/express@5.2.1/node_modules/express  (symlink)
.bun/express@5.2.1/node_modules/express → $TMPDIR/cache/...     (symlink to temp)
$TMPDIR/cache/... → bunDeps/share/bun-packages/express@5.2.1/   (symlink to store)
```

But the middle `.bun/` entries are actually **real directories** (copies from the cache), not symlinks. This means `readlink -f` (even when available) resolves into the build sandbox — not the nix store.

**Fix:** Don't chase symlinks at all. Read the first-level symlink target (`readlink`, not `readlink -f`), extract the `pkg@ver` with regex, and link directly to `bunDeps/share/bun-packages/pkg@ver`.

### Problem 3: `cp -rL node_modules` is too slow

Dereferencing 2933 packages (including all devDependencies — TypeScript, ESLint, Vite, React, etc.) takes 10+ minutes and produces gigabytes of output. Build consistently timed out.

**Fix:** Don't copy `node_modules` at all. The manifest approach symlinks ~80 runtime packages directly to the nix store, producing a 22MB output.

### Problem 4: `cp -a node_modules` also too slow

Even preserving symlinks (`cp -a`), the `.bun/` directory tree is massive (deep nesting with `node_modules/<pkg>@<ver>/node_modules/<pkg>/` for every package). Copying this structure alone takes minutes.

**Fix:** Same as above — skip `.bun/` entirely, symlink to `bunDeps` directly.

### Problem 5: Scoped package regex

Initial regex `\.bun/([^/]+)/node_modules/` breaks on scoped packages because `[^/]+` stops at the `/` in `@codemirror/autocomplete@6.20.0`. The scope separator `/` is also a path separator.

**Fix:** Separate handling for scoped (`\.bun/([^/]+/[^/]+)/node_modules/`) vs. unscoped (`\.bun/([^/]+)/node_modules/`) packages.

### Problem 6: Peer-dependency `+wyhash` suffixes

Bun disambiguates peer-dependency variants by appending `+wyhash` to the version (e.g., `react-dom@19.2.4+b1ab299f0a400331`). These variants don't exist in `bunDeps/share/bun-packages/` (which stores the canonical version without suffix).

**Fix:** Strip the suffix: `pkgver_clean="${pkgver%%+*}"`.

## Consequences

### Benefits

- **22MB output** — symlinks to nix store instead of copying packages
- **~30s build** — Vite build (~17s) + bun install (~12s), no slow copy/fixup
- **Sandboxed** — no impure network access during build
- **Granular caching** — per-package FODs via `fetchBunDeps`
- **Correct module resolution** — symlinks into `bunDeps` nix store paths; bun/node resolve normally

### Trade-offs

- **External flake input** — `bun2nix` is not in nixpkgs
- **Modified `bun.nix`** — workspace paths manually patched for `fetchFromGitHub`
- **Manifest approach is custom** — not a standard bun2nix pattern; we bypass the hook's install logic
- **Runtime deps are implicit** — the manifest captures whatever `bun install` puts in `node_modules/`, not a declared set

## Appendix A: bunDeps Store Layout

```
$bunDeps/
└── share/
    ├── bun-cache/          # symlinks with @@@1 suffix (internal to bun)
    │   ├── express@5.2.1@@@1 → ../bun-packages/express@5.2.1
    │   └── ...
    └── bun-packages/       # actual package contents
        ├── express@5.2.1/
        │   ├── index.js
        │   ├── lib/
        │   └── package.json
        ├── @codemirror/
        │   └── autocomplete@6.20.0/
        │       ├── dist/
        │       └── package.json
        └── ...
```

## Appendix B: Symlink Chain During Build

```
# After bun install --linker=isolated --backend=symlink (macOS):

node_modules/
├── express → .bun/express@5.2.1/node_modules/express       (relative symlink)
├── @codemirror/
│   └── autocomplete → ../.bun/@codemirror/autocomplete@6.20.0/node_modules/@codemirror/autocomplete
├── .bun/
│   ├── express@5.2.1/
│   │   └── node_modules/
│   │       └── express/          ← REAL DIRECTORY (copy from cache)
│   │           ├── index.js
│   │           └── package.json
│   └── @codemirror/
│       └── autocomplete@6.20.0/
│           └── node_modules/
│               └── @codemirror/
│                   └── autocomplete/   ← REAL DIRECTORY
└── .bin/
    └── ...                      (bin symlinks, not needed at runtime)

# After our installPhase:

$out/lib/openchamber/
├── node_modules/
│   ├── express → /nix/store/...-bun-cache/share/bun-packages/express@5.2.1
│   └── @codemirror/
│       └── autocomplete → /nix/store/...-bun-cache/share/bun-packages/@codemirror/autocomplete@6.20.0
├── packages/web/
│   ├── dist/           (Vite-built SPA)
│   ├── server/         (pre-compiled Express server)
│   ├── bin/cli.js
│   ├── node_modules/   (workspace-specific packages, same symlink pattern)
│   ├── public/
│   └── package.json
```

## Appendix C: Future Upgrade Concerns

When upgrading OpenChamber to a new version, several things may break:

### C.1: Regenerating `bun.nix`

The `bun.nix` file must be regenerated with `bun2nix` whenever dependencies change. The workspace path modifications (`workspaceSrc = fetchFromGitHub ...`) must be reapplied manually after regeneration.

**Potential fix:** Write a script that runs `bun2nix -o bun.nix` and then patches in the `workspaceSrc` block automatically. Or contribute workspace-from-store support upstream to bun2nix.

### C.2: New runtime dependencies

If the server adds new `require()` / `import` calls, those packages need to appear in either root or `packages/web` `node_modules/`. The manifest approach captures whatever `bun install` puts there — so as long as the new dep is in `package.json` and `bun.lock`, it should appear automatically. But if the dep is hoisted differently or only accessible via a transitive path not in our two `node_modules/` trees, it could be missed.

**Potential fix:** Add a runtime smoke test (e.g., `openchamber serve --check` or a curl against localhost) to CI.

### C.3: Native dependencies

OpenChamber depends on `sharp` (via `vips`) and `node-pty` (native addons). These require `python3`, `pkg-config`, and `vips` at build time. If upstream adds more native deps, the build will fail at the lifecycle scripts phase.

**Potential fix:** Inspect bun install lifecycle script errors; add missing `nativeBuildInputs`/`buildInputs` as needed.

### C.4: `bun.lock` format changes

bun2nix requires `bun.lock` (JSON format, Bun 1.2+). If upstream somehow regresses to `bun.lockb` (binary), bun2nix can't parse it.

**Potential fix:** Regenerate the lockfile with a modern bun: `nix shell nixpkgs#bun -c bun install` in the upstream source.

### C.5: Peer-dependency variant changes

The `+wyhash` suffix stripping (`${pkgver%%+*}`) assumes `bunDeps` always stores the canonical version without the suffix. If `fetchBunDeps` changes to include variant suffixes, our stripping logic would create mismatches.

**Potential fix:** Try exact match first, fall back to stripped match. Monitor bun2nix changelogs.

### C.6: Server entrypoint changes

The wrapper hardcodes `bun cli.js serve`. If the server entrypoint moves or the CLI changes its subcommand structure, the wrapper breaks silently (bun may exit 0 with an error message).

**Potential fix:** Add a `passthru.tests` attribute that verifies `openchamber --help` succeeds.

### C.7: `node_modules` layout differences on Linux vs. macOS

On macOS, `bun install --linker=isolated` uses `--backend=symlink`, creating symlinks in `.bun/`. On Linux, bun may use `--backend=hardlink` or `--backend=copyfile`, producing a different `.bun/` structure. Our regex-based manifest extraction assumes the `.bun/<pkg>@<ver>/node_modules/<pkg>` layout.

**Potential fix:** Test the build on both platforms. If the layout differs, the `_build_manifest` function may need platform-specific logic. We may need to inspect `readlink` output more carefully or use different extraction strategies per backend.

## Alternatives Considered

### Alternative A — Continue with impure FOD + `cp -rL` (ADR-026)

Fundamentally broken: destroyed module resolution, 17-minute fixup, fragile hash management.

### Alternative B — `buildNpmPackage` with `package-lock.json`

Would require maintaining a separate `package-lock.json` diverging from upstream's `bun.lock`. Still viable as a fallback if bun2nix becomes unmaintained.

### Alternative C — `dream2nix`

No Bun support. Experimental/unstable APIs.

### Alternative D — Copy node_modules with `cp -a` or `cp -rL`

Both are too slow for 2933 packages. `cp -rL` takes 10+ minutes and produces gigabytes. `cp -a` preserves dangling symlinks that fail `noBrokenSymlinks`. The manifest approach avoids copying entirely.

### Alternative E — Run `bun install` directly in `$out`

Doesn't work: `bun install` needs a `package.json` + `bun.lock` that match, and a trimmed workspace JSON doesn't match the monorepo lockfile.

## Related

- ADR-026 (superseded)
- [nix-community/bun2nix](https://github.com/nix-community/bun2nix)
- [btriapitsyn/openchamber](https://github.com/btriapitsyn/openchamber)

______________________________________________________________________

Author: jack
Date: 2026-02-19
PR: N/A
=======
---
id: ADR-027
title: "Openchamber Bun2nix Pivot"
status: proposed
date: 2026-02-19
---

# ADR 027: Openchamber Bun2nix Pivot
*Date:* 2026-02-19
*Status:* proposed

**Related PR:** https://github.com/jmmaloney4/jackpkgs/pull/156

This ADR is currently being developed in linked pull request above.
Please refer to that PR for current content and discussion.
>>>>>>> main
